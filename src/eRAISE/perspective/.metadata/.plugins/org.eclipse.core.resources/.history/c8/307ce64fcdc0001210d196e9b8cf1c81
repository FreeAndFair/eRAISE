/**
 * 
 */
package core;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Collections;
import java.util.Map;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.osgi.framework.Bundle;



/**
 * @author Marieta V. Fasie
 * 	marietafasie at gmail dot com
 *
 */
public class TypeChecker {

	private static PluginLog log = PluginLog.getInstance();
	
	private static int count = 0;
	/**
	 * Type checks an RSL file
	 * 
	 * @param context an RSL file
	 */
	public void typeCheck(IFile ifile){
		
		log.debug("Enter typeCheck method");
		
		if(count == 0){
			//Activator.getDefault().setBinariesPath();
			count++;
		}
		
		String infomessage = "";
		Process process = null;
		
		log.debug("Current platform: "+System.getProperty("os.name"));
		
		//path of the file opened in the editor
		IPath ipath = ifile.getLocation();
		String filePath = ipath.toString();
		ProcessBuilder builder = null;
		
		String os = System.getProperty("os.name");
		
		//String programPath = System.getProperty("rsltc");
		//String programPath =  accessRuntimeResource("resources/raise/rsl/rsltc.exe");
		
		//String programPath = findPluginResource("rsl.core", "resources/raise/rsl/rsltc.exe");
		
		
		if( os.indexOf("win") >= 0 || os.indexOf("Win")>=0){
			
			/*
			 * to execute a DOS command from a Java program, you need to prepend
			 * the Windows command shell cmd /c to the command
			 * you want to execute. In other words the type checker
			 * needs to be wrapped in the cmd.
			 * The '/c' switch terminates the command shell after the command completes
			 */
			//programPath = "\""+ programPath+"\"";
			
			
			//String commands[] = {"cmd", "/C", programPath, filePath};
		
			
			//builder = new ProcessBuilder("cmd","/C", programPath, filePath);
			/*
			if(count < 3){
				Console.getInstance().print("running ... rsltc.exe ");
				builder = new ProcessBuilder("rsltc.exe", filePath);
				count++;
			}
			else
			if(count < 4){
				Console.getInstance().print("running cmd /c... rsltc.exe ");
				builder = new ProcessBuilder("cmd", "/C", "rsltc.exe", filePath);
				count++;
			}
			
			else{
			*/

				log.debug("Search path for rsltc.exe: "+System.getProperty("os.name"));
		 
				String resPath = findPluginResource("rsl.core", "rsltc.exe");
				
				log.debug("Building program: cmd /c \n    "+ resPath+" \n   "+filePath);
				builder = new ProcessBuilder("cmd", "/C", resPath, filePath);
				
			//}
			
		
			Map<String, String> env = builder.environment();
			
			//String pathVal = findPluginResource("rsl.core", "resources/sml");
			
			if (! env.containsKey("Path")) {
				log.debug("Adding env variable: "+"C:\\Program Files\\eclipse\\plugins");
		    	env.put("Path", "C:\\Program Files\\eclipse\\plugins");	    	
		    }
			else{
				String path = env.get("Path");
				if(!path.contains(resPath)){
					log.debug("Adding env variable: "+";C:\\Program Files\\eclipse\\plugins");
					path = path.concat(";"+"C:\\Program Files\\eclipse\\plugins");
					env.put("Path", path);
				}
			}
			
			/*
			if (! env.containsKey("Path")) {
		    	//System.out.println("Path is NULL");
		    	env.put("Path", pathVal+"\\bin\\");	    	
		    }
			else{
				String path = env.get("Path");
				if(!path.contains(pathVal+"\\bin\\")){
					path = path.concat(";"+pathVal+"\\bin\\");
					env.put("Path", path);
				}
			}
			
			if (! env.containsKey("SMLNJ_PATH")) {
				//System.out.println("SMLNJ_PATH is NULL");
				env.put("SMLNJ_HOME", pathVal);
			    	
			}
			
			String rslPathVal = findPluginResource("rsl.core", "resources/raise/sml");
		    if (! env.containsKey("RSLML_PATH")) {
		    	//System.out.println("RSLML_PATH is NULL");
		    	env.put("RSLML_HOME", rslPathVal);
		    	
		    }
			*/
			//correlate the error messages with the output messages
			builder.redirectErrorStream(true);
		}
		
		else{
			
			if(os.indexOf("nix") >= 0 || os.indexOf("nux") >= 0 || os.indexOf("aix") > 0 ){
				//linux							
				
				//give rights
				String programPath = findPluginResource("rsl.core","resources/linux/raise/rsltc");
				log.debug("rsltc path: "+programPath);
				
				ProcessBuilder giveRights = new ProcessBuilder("chmod", "777",programPath);
				log.debug("Rights given");
				try {
					giveRights.start();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
				//String commands[] = {programPath, filePath};
					
				builder = new ProcessBuilder(programPath, filePath);
			}
		}
		
		//correlate the error messages with the output messages
		builder.redirectErrorStream(true);
				
		try {
			//start the program
			Console.getInstance().print("Process started...");
			process = builder.start();
		
			//get the input stream
			InputStream is = process.getInputStream();
			InputStreamReader isr = new InputStreamReader(is);
			BufferedReader br = new BufferedReader(isr);
			
			//read the program output line by line
			String line = br.readLine();
						
			while (line != null && ! line.trim().equals("--EOF--")) {
		        infomessage += line+"\n";
		        line = br.readLine();
		    }
		
			Console.getInstance().print("Program finished\n");
		} catch (IOException e) {
			infomessage += e.getMessage();
			//e.printStackTrace();
		}
		
		Console.getInstance().print("Info message:");
		Console.getInstance().print(infomessage);
		
	}
	
	/**
	 * This method takes a relative path of a file and
	 * returns the absolute path of the file according
	 * to the runtime workspace
	 * 
	 * @param relativePath
	 * @return the absolute path  
	 */
	private String accessRuntimeResource(String relativePath) {
		
		Console.getInstance().print("Enter accessRuntimeResource");
		File setupFile = null;
		
		//get access to bundle
		Bundle bundle = Activator.getDefault().getBundle();
		
		Console.getInstance().print("Bundle obtained");
		//get the runtime path to the resources/rsltc program
		IPath path = new Path(relativePath);		
		
		Console.getInstance().print("New path");
		URL setupUrl = FileLocator.find(bundle, path, Collections.EMPTY_MAP);
		//Activator.getDefault().getLog().log(status);
		Console.getInstance().print("setup URL "+setupUrl);
		//get the file with the absolute path 
		try {
			setupFile = new File(FileLocator.toFileURL(setupUrl).toURI());	
			Console.getInstance().print("setupFile "+setupFile);
		
		} catch (URISyntaxException | IOException e) {			
			e.printStackTrace();
		}
		
		return setupFile.getAbsolutePath();
		
	}
	
	 /**
	   * Returns the absolute file system location of a file inside a plugin.
	   * @param pluginName  The name of the plugin
	   * @param path  The path (as a String) of the file within the plugin
	   * @return The absolute file system location of the target file
	   * @throws IOException
	   */
	  public static String findPluginResource(final String pluginName, 
	                                          final String path){
		 Console.getInstance().print("---enter findPLuginresource");
	    // This is the 'official' way to find something that
	    // is in the install location of the plugin, cf.
	    // Official Eclipse Faq #103.
	    // It is stated that this code will only work if the 
	    // install location is on the local file system.
	    final Bundle bundle = Platform.getBundle(pluginName);
	    
	    Console.getInstance().print("getting bundle");
	    IPath p = new Path(path);
	    final URL url = FileLocator.find(bundle, p, null);
	    Console.getInstance().print("getting url: "+url);
	    // The substring call is to remove an initial /
	    // FIXME do we remove the / on all platforms?
	    // FIXME - do we need to do these back-and-forth conversions of will this do:
	    // return Platform.resolve(url).getPath().substring(1);
	    URL resolvedURL=null;
		try {
			resolvedURL = FileLocator.resolve(url);
			Console.getInstance().print("resolved url: "+resolvedURL);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    final String filePath = resolvedURL.getPath();
	    Console.getInstance().print("resolved filePath: "+filePath);
	    
	    final Path resourcePath = new Path(filePath);
	    Console.getInstance().print("resourcePath: "+resourcePath);
	    p = resourcePath.makeAbsolute();
	    
	    Console.getInstance().print(" p: "+p);
	    String s = p.toOSString();
	    
	    if(s.startsWith("file:/") || s.startsWith("file:\\"))
	    	s = s.substring(6);
	   
	    /*
	    if(s.contains("!")){
	    	int position = s.indexOf("!");
	    	s = s.substring(0,position) + s.substring(position+1,s.length());
	    }
	    */
	    Console.getInstance().print("----Returning "+s);
	    return s;
	  }
	
}
