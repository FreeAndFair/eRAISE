package core;

import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.ISafeRunnable;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.SafeRunner;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.ui.plugin.AbstractUIPlugin;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;



/**
 * The activator class controls the plug-in life cycle
 */
public class Activator extends AbstractUIPlugin {

	// The plug-in ID
	public static final String PLUGIN_ID = "core"; //$NON-NLS-1$

	// The shared instance
	private static Activator plugin;
	
	//logger
	private static PluginLog log = PluginLog.getInstance();
	
	//rsltc binaries
	public static String [][] binaries = {
	    {"Windows", "rsltc", "resources/raise/rsl/rsltc.exe"},
	    {"Windows", "sml", "resources/sml/",""},
	    {"Linux", "rsltc", "resources/linux/raise/rsltc"},
	    {"Linux", "sml","reources/linux/sml/bin/sml"}
	};
	
	
	//Don't initialize to lazily compute the listeners
	private List<IRSLTestCasesListener> listeners ;
	
	
	private static final String LISTENER_ID = "rsl.core.testcaseslisteners";
	/**
	 * The constructor
	 */
	public Activator() {
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.ui.plugin.AbstractUIPlugin#start(org.osgi.framework.BundleContext)
	 */
	public void start(BundleContext context) throws Exception {
		super.start(context);
		plugin = this;
	}

	/*
	 * (non-Javadoc)
	 * @see org.eclipse.ui.plugin.AbstractUIPlugin#stop(org.osgi.framework.BundleContext)
	 */
	public void stop(BundleContext context) throws Exception {
		plugin = null;
		super.stop(context);
	}

	/**
	 * Returns the shared instance
	 *
	 * @return the shared instance
	 */
	public static Activator getDefault() {
		return plugin;
	}

	/**
	 * Returns an image descriptor for the image file at the given
	 * plug-in relative path
	 *
	 * @param path the path
	 * @return the image descriptor
	 */
	public static ImageDescriptor getImageDescriptor(String path) {
		return imageDescriptorFromPlugin(PLUGIN_ID, path);
	}

	/**
	 * Calls all listeners when a series of test are started
	 * ex: when the RT button is pressed
	 */
	public void testsStarted(){
		Iterator<IRSLTestCasesListener> it = getListeners().iterator();
		
		//for each listener
		log.debug("Calls every listener");
		while(it.hasNext()){
			final IRSLTestCasesListener listener = (IRSLTestCasesListener) it.next();
			
			log.debug("Create runnable");
			ISafeRunnable runnable = new ISafeRunnable() {
				
				@Override
				public void run() throws Exception {
					listener.testsStarted();
					
				}
				
				@Override
				public void handleException(Throwable exception) {
					;					
				}
			};
				
			log.debug("Run for every listener");
			SafeRunner.run(runnable);
		}
	}
	
	private List<IRSLTestCasesListener> getListeners() {
		if( listeners == null){
			listeners = computeListeners();
			log.debug("Listeners computed");
		}
		return listeners;
	}

	private List<IRSLTestCasesListener> computeListeners() {
		log.debug("---- Enter compute listeners");
		
		IExtensionRegistry registry = Platform.getExtensionRegistry();
		IExtensionPoint extensionPoint = registry.getExtensionPoint(LISTENER_ID);
		IExtension[] extensions = extensionPoint.getExtensions();
		
		ArrayList<IRSLTestCasesListener> list = new ArrayList<IRSLTestCasesListener>();
		
		//for each extension to our extension point
		for(int index = 0; index < extensions.length; index++){
			IConfigurationElement[] elements = extensions[index].getConfigurationElements();
			
			//for each configuration element of a extension 
			for(int j = 0; j < elements.length; j++){
				try {
					Object listener = elements[j].createExecutableExtension("class");
					if(listener instanceof IRSLTestCasesListener)
						log.debug("Added listener");
						list.add((IRSLTestCasesListener)listener);
				} catch (CoreException e) {
					log.error(e.getMessage(), e);
				}
			}
		}
		Console.getInstance().print("---- end compute listeners");
		return list;
	}

	/**
	 * Calls all listeners when all tests in a file are finished
	 * 
	 * @param name
	 * @param message
	 * @param ifile
	 */
	public void testsFinished(String message, IFile ifile) {
		Iterator<IRSLTestCasesListener> it = getListeners().iterator();
		final String msg = message;
		final IFile file = ifile;
		
		//for each listener
		while(it.hasNext()){
			final IRSLTestCasesListener listener = (IRSLTestCasesListener) it.next();
			
			ISafeRunnable runnable = new ISafeRunnable() {
				
				@Override
				public void run() throws Exception {
					listener.testFinished(msg, file);
				}
				
				@Override
				public void handleException(Throwable exception) {
					//TODO what happens if an listener throws exception?
					
				}
			};
				
			SafeRunner.run(runnable);
		}
		
	}
	
	
	public void addListener(IRSLTestCasesListener listener){
		listeners.add(listener);
	}
	
	public void removeListener(IRSLTestCasesListener listener){
		listeners.remove(listener);
	}
	
	
	public void setBinariesPath(){
		String os = System.getProperty("os.name");
		
		if(os.indexOf("win") >= 0 || os.indexOf("Win")>=0){
			//windows
			//System.out.println("Loading libraries windows");
			String rsltcWin = binaries[0][2];
			System.setProperty("rsltc", accessRuntimeResource(rsltcWin));
		}
		else
			if(os.indexOf("nix") >= 0 || os.indexOf("nux") >= 0 || os.indexOf("aix") > 0 ){
				//linux
				//System.out.println("Loading libraries linux");
				String rsltcWin = binaries[2][2];
				System.setProperty("rsltc", accessRuntimeResource(rsltcWin));
				String smlWin = binaries[3][2];
				System.setProperty("smlLinux", accessRuntimeResource(smlWin));
			}
		
		
	}
	
	/**
	 * This method takes a relative path of a file and
	 * returns the absolute path of the file according
	 * to the runtime workspace
	 * 
	 * @param relativePath
	 * @return the absolute path  
	 */
	private String accessRuntimeResource(String relativePath) {
		File setupFile = null;
		
		//get access to bundle
		Bundle bundle = Activator.getDefault().getBundle();
		
		//get the runtime path to the resources/rsltc program
		IPath path = new Path(relativePath);				
		URL setupUrl = FileLocator.find(bundle, path, Collections.EMPTY_MAP);
		
		//get the file with the absolute path 
		try {
			setupFile = new File(FileLocator.toFileURL(setupUrl).toURI());	
		
		} catch (URISyntaxException | IOException e) {	
			//System.out.println(e.getMessage());
			e.printStackTrace();
		}
	
		return setupFile.getAbsolutePath();
	}

	
	 /**
	   * Returns the absolute file system location of a file inside a plugin.
	   * @param pluginName  The name of the plugin
	   * @param path  The path (as a String) of the file within the plugin
	   * @return The absolute file system location of the target file
	   * @throws IOException
	   */
	  public static String findPluginResource(final String pluginName, 
	                                          final String path){
		 Console.getInstance().print("---enter findPLuginresource");
	    // This is the 'official' way to find something that
	    // is in the install location of the plugin, cf.
	    // Official Eclipse Faq #103.
	    // It is stated that this code will only work if the 
	    // install location is on the local file system.
	    final Bundle bundle = Platform.getBundle(pluginName);
	    
	    Console.getInstance().print("getting bundle");
	    IPath p = new Path(path);
	    final URL url = FileLocator.find(bundle, p, null);
	    Console.getInstance().print("getting url: "+url);
	    // The substring call is to remove an initial /
	    // FIXME do we remove the / on all platforms?
	    // FIXME - do we need to do these back-and-forth conversions of will this do:
	    // return Platform.resolve(url).getPath().substring(1);
	    URL resolvedURL=null;
		try {
			resolvedURL = FileLocator.resolve(url);
			Console.getInstance().print("resolved url: "+resolvedURL);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	    final String filePath = resolvedURL.getPath();
	    Console.getInstance().print("resolved filePath: "+filePath);
	    
	    final Path resourcePath = new Path(filePath);
	    Console.getInstance().print("resourcePath: "+resourcePath);
	    p = resourcePath.makeAbsolute();
	    
	    Console.getInstance().print(" p: "+p);
	    String s = p.toOSString();
	    
	    if(s.startsWith("file:/") || s.startsWith("file:\\"))
	    	s = s.substring(6);
	   
	    /*
	    if(s.contains("!")){
	    	int position = s.indexOf("!");
	    	s = s.substring(0,position) + s.substring(position+1,s.length());
	    }
	    */
	    Console.getInstance().print("----Returning "+s);
	    return s;
	  }
	
}
